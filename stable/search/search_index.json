{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Weave.jl - Scientific Reports Using Julia This is the documentation of Weave.jl . Weave is a scientific report generator/literate programming tool for Julia. It resembles Pweave , Knitr, rmarkdown and Sweave. Current features Noweb, markdown or script syntax for input documents. Execute code as terminal or \"script\" chunks. Capture Plots (or Gadfly and PyPlot figures on 0.6) . Supports LaTex, Pandoc, Github markdown, MultiMarkdown, Asciidoc and reStructuredText output Publish markdown directly to html and pdf using julia or Pandoc markdown. Simple caching of results Convert to and from IJulia notebooks Contents Getting started Using Weave Weave Tangle Supported formats Document syntax Noweb format Markdown format Script format Inline code Passing arguments to documents Include Weave document in Julia Publishing to html and pdf Templates Chunk options Options for code Options for figures Set default chunk options Working with Jupyter notebooks Weaving from Jupyter notebooks Output to Jupyter notebooks Converting between formats Function index","title":"Home"},{"location":"#weavejl-scientific-reports-using-julia","text":"This is the documentation of Weave.jl . Weave is a scientific report generator/literate programming tool for Julia. It resembles Pweave , Knitr, rmarkdown and Sweave. Current features Noweb, markdown or script syntax for input documents. Execute code as terminal or \"script\" chunks. Capture Plots (or Gadfly and PyPlot figures on 0.6) . Supports LaTex, Pandoc, Github markdown, MultiMarkdown, Asciidoc and reStructuredText output Publish markdown directly to html and pdf using julia or Pandoc markdown. Simple caching of results Convert to and from IJulia notebooks","title":"Weave.jl - Scientific Reports Using Julia"},{"location":"#contents","text":"Getting started Using Weave Weave Tangle Supported formats Document syntax Noweb format Markdown format Script format Inline code Passing arguments to documents Include Weave document in Julia Publishing to html and pdf Templates Chunk options Options for code Options for figures Set default chunk options Working with Jupyter notebooks Weaving from Jupyter notebooks Output to Jupyter notebooks Converting between formats Function index","title":"Contents"},{"location":"chunk_options/","text":"Chunk options I've mostly followed Knitr 's naming for chunk options, but not all options are implemented. Options are separated using \";\" and need to be valid Julia expressions. Example: A code chunk that saves and displays a 12 cm wide image and hides the source code: << out_width = \"12cm\" ; echo = false >>= using Gadfly x = linspace ( 0 , 2 \u03c0 , 200 ) plot ( x = x , y = sin ( x ), Geom . line ) @ Weave currently supports the following chunk options with the following defaults: Options for code echo = true . Echo the code in the output document. If false the source code will be hidden. results = \"markup\" . The output format of the printed results. \"markup\" for literal block, \"hidden\" for hidden results or anything else for raw output (I tend to use \u2018tex\u2019 for Latex and \u2018rst\u2019 for rest. Raw output is useful if you wan\u2019t to e.g. create tables from code chunks. eval = true . Evaluate the code chunk. If false the chunk won\u2019t be executed. term=false . If true the output emulates a REPL session. Otherwise only stdout and figures will be included in output. label . Chunk label, will be used for figure labels in Latex as fig:label wrap = true . Wrap long lines from output. line_width = 75 . Line width for wrapped lines. cache = false . Cache results, depends on cache parameter on weave function. hold = false . Hold all results until the end of the chunk. tangle = true . Set tangle to false to exclude chunk from tangled code. Options for figures fig_width . Figure width passed to plotting library e.g. 800 fig_height Figure height passed to plotting library out_width . Width of saved figure in output markup e.g. \"50%\", \"12cm\", \\\\0.5linewidth out_height . Height of saved figure in output markup dpi =96. Resolution of saved figures. fig_cap . Figure caption. label . Chunk label, will be used for figure labels in Latex as fig:label fig_ext . File extension (format) of saved figures. fig_pos=\"htpb\" . Figure position in Latex. fig_env=\"figure\" . Figure environment in Latex. Set default chunk options You can set or change the default chunk options for a document either before running weave or inside the weaved document. You can e.g. use a hidden chunk in the beginning of the source document to set the options: << echo = false >>= import Weave Weave . set_chunk_defaults ( Dict { Symbol , Any }( : out_width => \" \\\\ 0.5linewidth\" , : results => \"tex\" )) @ set_chunk_defaults(opts) get_chunk_defaults() restore_chunk_defaults()","title":"Chunk options"},{"location":"chunk_options/#chunk-options","text":"I've mostly followed Knitr 's naming for chunk options, but not all options are implemented. Options are separated using \";\" and need to be valid Julia expressions. Example: A code chunk that saves and displays a 12 cm wide image and hides the source code: << out_width = \"12cm\" ; echo = false >>= using Gadfly x = linspace ( 0 , 2 \u03c0 , 200 ) plot ( x = x , y = sin ( x ), Geom . line ) @ Weave currently supports the following chunk options with the following defaults:","title":"Chunk options"},{"location":"chunk_options/#options-for-code","text":"echo = true . Echo the code in the output document. If false the source code will be hidden. results = \"markup\" . The output format of the printed results. \"markup\" for literal block, \"hidden\" for hidden results or anything else for raw output (I tend to use \u2018tex\u2019 for Latex and \u2018rst\u2019 for rest. Raw output is useful if you wan\u2019t to e.g. create tables from code chunks. eval = true . Evaluate the code chunk. If false the chunk won\u2019t be executed. term=false . If true the output emulates a REPL session. Otherwise only stdout and figures will be included in output. label . Chunk label, will be used for figure labels in Latex as fig:label wrap = true . Wrap long lines from output. line_width = 75 . Line width for wrapped lines. cache = false . Cache results, depends on cache parameter on weave function. hold = false . Hold all results until the end of the chunk. tangle = true . Set tangle to false to exclude chunk from tangled code.","title":"Options for code"},{"location":"chunk_options/#options-for-figures","text":"fig_width . Figure width passed to plotting library e.g. 800 fig_height Figure height passed to plotting library out_width . Width of saved figure in output markup e.g. \"50%\", \"12cm\", \\\\0.5linewidth out_height . Height of saved figure in output markup dpi =96. Resolution of saved figures. fig_cap . Figure caption. label . Chunk label, will be used for figure labels in Latex as fig:label fig_ext . File extension (format) of saved figures. fig_pos=\"htpb\" . Figure position in Latex. fig_env=\"figure\" . Figure environment in Latex.","title":"Options for figures"},{"location":"chunk_options/#set-default-chunk-options","text":"You can set or change the default chunk options for a document either before running weave or inside the weaved document. You can e.g. use a hidden chunk in the beginning of the source document to set the options: << echo = false >>= import Weave Weave . set_chunk_defaults ( Dict { Symbol , Any }( : out_width => \" \\\\ 0.5linewidth\" , : results => \"tex\" )) @ set_chunk_defaults(opts) get_chunk_defaults() restore_chunk_defaults()","title":"Set default chunk options"},{"location":"function_index/","text":"Function index Weave.convert_doc Weave.get_chunk_defaults Weave.include_weave Weave.list_out_formats Weave.notebook Weave.restore_chunk_defaults Weave.tangle Weave.weave","title":"Function index"},{"location":"function_index/#function-index","text":"Weave.convert_doc Weave.get_chunk_defaults Weave.include_weave Weave.list_out_formats Weave.notebook Weave.restore_chunk_defaults Weave.tangle Weave.weave","title":"Function index"},{"location":"getting_started/","text":"Getting started The best way to get started using Weave.jl is to look at the example input and output documents. Examples for different formats are included in the packages examples directory. First have a look at source document using markdown code chunks and Plots.jl for figures: FIR_design.jmd and then see the output in different formats: Pandoc markdown: FIR_design.txt HTML: FIR_design.html pdf: FIR_design.pdf Producing pdf output requires that you have pdflatex installed. Add dependencies for the example if needed: using Pkg ; Pkg . add . ([ \"Plots\" , \"DSP\" ]) Weave the files to your working directory using: using Weave #Markdown weave ( joinpath ( dirname ( pathof ( Weave )), \"../examples\" , \"FIR_design.jmd\" ), doctype = \"pandoc\" out_path =: pwd ) #HTML weave ( joinpath ( dirname ( pathof ( Weave )), \"../examples\" , \"FIR_design.jmd\" ), out_path =: pwd , doctype = \"md2html\" ) #pdf weave ( joinpath ( dirname ( pathof ( Weave )), \"../examples\" , \"FIR_design.jmd\" ), out_path =: pwd , doctype = \"md2pdf\" )","title":"Getting started"},{"location":"getting_started/#getting-started","text":"The best way to get started using Weave.jl is to look at the example input and output documents. Examples for different formats are included in the packages examples directory. First have a look at source document using markdown code chunks and Plots.jl for figures: FIR_design.jmd and then see the output in different formats: Pandoc markdown: FIR_design.txt HTML: FIR_design.html pdf: FIR_design.pdf Producing pdf output requires that you have pdflatex installed. Add dependencies for the example if needed: using Pkg ; Pkg . add . ([ \"Plots\" , \"DSP\" ]) Weave the files to your working directory using: using Weave #Markdown weave ( joinpath ( dirname ( pathof ( Weave )), \"../examples\" , \"FIR_design.jmd\" ), doctype = \"pandoc\" out_path =: pwd ) #HTML weave ( joinpath ( dirname ( pathof ( Weave )), \"../examples\" , \"FIR_design.jmd\" ), out_path =: pwd , doctype = \"md2html\" ) #pdf weave ( joinpath ( dirname ( pathof ( Weave )), \"../examples\" , \"FIR_design.jmd\" ), out_path =: pwd , doctype = \"md2pdf\" )","title":"Getting started"},{"location":"notebooks/","text":"Working with Jupyter notebooks Weaving from Jupyter notebooks Weave supports using Jupyter notebooks as input format, this means you can weave notebooks to any supported formats. You can't use chunk options with notebooks. weave ( \"notebook.ipynb\" ) Output to Jupyter notebooks As of Weave 0.5.1. there is new notebook method to convert Weave documents to Jupyter notebooks using nbconvert . The code is not executed by Weave and the output doesn't always work properly, see #116 . # Weave.notebook \u2014 Function . notebook(source::String, out_path=:pwd) Convert Weave document source to Jupyter notebook and execute the code using nbconvert. Requires IJulia. Ignores all chunk options out_path : Path where the output is generated. Can be: :doc : Path of the source document, :pwd : Julia working directory, \"somepath\" : Path as a String e.g \"/home/mpastell/weaveout\" nbconvert cell timeout in seconds. Defaults to -1 (no timeout) source You might wan't to use the convert_doc method below instead and run the code in Jupyter. Converting between formats You can convert between all supported input formats using the convert_doc function. To convert from script to notebook: convert_doc ( \"examples/FIR_design.jl\" , \"FIR_design.ipynb\" ) and from notebooks to markdown use: convert_doc ( \"FIR_design.ipynb\" , \"FIR_design.jmd\" ) # Weave.convert_doc \u2014 Method . convert_doc(infile::AbstractString, outfile::AbstractString; format = nothing) Convert Weave documents between different formats infile = Name of the input document outfile = Name of the output document format = Output format (optional). Detected from outfile extension, but can be set to \"script\" , \"markdown\" , \"notebook\" or \"noweb\" . source","title":"Working with Jupyter notebooks"},{"location":"notebooks/#working-with-jupyter-notebooks","text":"","title":"Working with Jupyter notebooks"},{"location":"notebooks/#weaving-from-jupyter-notebooks","text":"Weave supports using Jupyter notebooks as input format, this means you can weave notebooks to any supported formats. You can't use chunk options with notebooks. weave ( \"notebook.ipynb\" )","title":"Weaving from Jupyter notebooks"},{"location":"notebooks/#output-to-jupyter-notebooks","text":"As of Weave 0.5.1. there is new notebook method to convert Weave documents to Jupyter notebooks using nbconvert . The code is not executed by Weave and the output doesn't always work properly, see #116 . # Weave.notebook \u2014 Function . notebook(source::String, out_path=:pwd) Convert Weave document source to Jupyter notebook and execute the code using nbconvert. Requires IJulia. Ignores all chunk options out_path : Path where the output is generated. Can be: :doc : Path of the source document, :pwd : Julia working directory, \"somepath\" : Path as a String e.g \"/home/mpastell/weaveout\" nbconvert cell timeout in seconds. Defaults to -1 (no timeout) source You might wan't to use the convert_doc method below instead and run the code in Jupyter.","title":"Output to Jupyter notebooks"},{"location":"notebooks/#converting-between-formats","text":"You can convert between all supported input formats using the convert_doc function. To convert from script to notebook: convert_doc ( \"examples/FIR_design.jl\" , \"FIR_design.ipynb\" ) and from notebooks to markdown use: convert_doc ( \"FIR_design.ipynb\" , \"FIR_design.jmd\" ) # Weave.convert_doc \u2014 Method . convert_doc(infile::AbstractString, outfile::AbstractString; format = nothing) Convert Weave documents between different formats infile = Name of the input document outfile = Name of the output document format = Output format (optional). Detected from outfile extension, but can be set to \"script\" , \"markdown\" , \"notebook\" or \"noweb\" . source","title":"Converting between formats"},{"location":"publish/","text":"Publishing to html and pdf You can also publish any supported input format using markdown for doc chunks to html and pdf documents. Producing pdf output requires that you have pdflatex installed and in your path. The markdown variant is Julia markdown . You can use a YAML header in the beginning of the input document delimited with \"\u2013-\" to set the document title, author and date e.g. --- title : Weave example author : Matti Pastell date: 15th December 2016 --- Here is a a sample document and output: FIR design plots.jl , FIR design plots.html , FIR design plots.pdf . weave ( \"FIR_design_plots.jl\" ) weave ( \"FIR_design_plots.jl\" , docformat = \"md2pdf\" ) Note: docformats md2pdf and md2html use Julia markdown and pandoc2pdf and pandoc2html use Pandoc. Templates You can use a custom template with md2pdf and md2html formats with template argument (e.g) weave(\"FIR_design_plots.jl\", template = \"custom.tpl\" ). You can use the existing templates as starting point. For HTML: julia_html.tpl and LaTex: julia_tex.tpl Templates are rendered using Mustache.jl .","title":"Publishing scripts"},{"location":"publish/#publishing-to-html-and-pdf","text":"You can also publish any supported input format using markdown for doc chunks to html and pdf documents. Producing pdf output requires that you have pdflatex installed and in your path. The markdown variant is Julia markdown . You can use a YAML header in the beginning of the input document delimited with \"\u2013-\" to set the document title, author and date e.g. --- title : Weave example author : Matti Pastell date: 15th December 2016 --- Here is a a sample document and output: FIR design plots.jl , FIR design plots.html , FIR design plots.pdf . weave ( \"FIR_design_plots.jl\" ) weave ( \"FIR_design_plots.jl\" , docformat = \"md2pdf\" ) Note: docformats md2pdf and md2html use Julia markdown and pandoc2pdf and pandoc2html use Pandoc.","title":"Publishing to html and pdf"},{"location":"publish/#templates","text":"You can use a custom template with md2pdf and md2html formats with template argument (e.g) weave(\"FIR_design_plots.jl\", template = \"custom.tpl\" ). You can use the existing templates as starting point. For HTML: julia_html.tpl and LaTex: julia_tex.tpl Templates are rendered using Mustache.jl .","title":"Templates"},{"location":"usage/","text":"Using Weave You can write your documentation and code in input document using Noweb, Markdown or script syntax and use weave function to execute to document to capture results and figures. Weave Weave document with markup and julia code using Plots.jl for plots, out_path = :pwd makes the results appear in the current working directory. #First add depencies for the example using Pkg ; Pkg . add . ([ \"Plots\" , \"DSP\" ]) using Weave weave ( joinpath ( dirname ( pathof ( Weave )), \"../examples\" , \"FIR_design.jmd\" ), out_path =: pwd ) # Weave.weave \u2014 Method . weave(source ; doctype = :auto, informat=:auto, out_path=:doc, args = Dict(), mod::Union{Module, Symbol} = Main, fig_path = \"figures\", fig_ext = nothing, cache_path = \"cache\", cache=:off, template = nothing, highlight_theme = nothing, css = nothing, pandoc_options = \"\", latex_cmd = \"xelatex\") Weave an input document to output file. doctype : :auto = set based on file extension or specify one of the supported formats. See list_out_formats() informat : :auto = set based on file extension or set to \"noweb\" , \"markdown\" or script out_path : Path where the output is generated. Can be: :doc : Path of the source document, :pwd : Julia working directory, \"somepath\" : output directory as a String e.g \"/home/mpastell/weaveout\" or filename as string e.g. ~/outpath/outfile.tex. args : dictionary of arguments to pass to document. Available as WEAVE_ARGS mod : Module where Weave eval s code. Defaults to :sandbox to create new sandbox module, you can also pass a module e.g. Main . fig_path : where figures will be generated, relative to out_path fig_ext : Extension for saved figures e.g. \".pdf\" , \".png\" . Default setting depends on doctype . cache_path : where of cached output will be saved. cache : controls caching of code: :off = no caching, :all = cache everything, :user = cache based on chunk options, :refresh , run all code chunks and save new cache. throw_errors if false errors are included in output document and the whole document is executed. if true errors are thrown when they occur. template : Template (file path) for md2html or md2tex formats. highlight_theme : Theme (Highlights.AbstractTheme) for used syntax highlighting css : CSS (file path) used for md2html format pandoc_options = String array of options to pass to pandoc for pandoc2html and pandoc2pdf formats e.g. [\"\u2013toc\", \"-N\"] latex_cmd the command used to make pdf from .tex Note: Run Weave from terminal and not using IJulia, Juno or ESS, they tend to mess with capturing output. source Tangle Tangling extracts the code from document: # Weave.tangle \u2014 Method . tangle(source ; out_path=:doc, informat=\"noweb\") Tangle source code from input document to .jl file. informat : \"noweb\" of \"markdown\" out_path : Path where the output is generated. Can be: :doc : Path of the source document, :pwd : Julia working directory, \"somepath\" , directory name as a string e.g \"/home/mpastell/weaveout\" or filename as string e.g. ~/outpath/outfile.jl. source Supported formats Weave sets the output format based on the file extension, but you can also set it using doctype option. The rules for detecting the format are: ext == \".jl\" && return \"md2html\" contains ( ext , \".md\" ) && return \"md2html\" contains ( ext , \".rst\" ) && return \"rst\" contains ( ext , \".tex\" ) && return \"texminted\" contains ( ext , \".txt\" ) && return \"asciidoc\" return \"pandoc\" You can get a list of supported output formats: list_out_formats () github : Github markdown md2tex : Julia markdown to latex pandoc2html : Markdown to HTML ( requires Pandoc 2 ) pandoc : Pandoc markdown pandoc2pdf : Pandoc markdown tex : Latex with custom code environments texminted : Latex using minted for highlighting md2html : Julia markdown to html rst : reStructuredText and Sphinx multimarkdown : MultiMarkdown md2pdf : Julia markdown to latex asciidoc : AsciiDoc hugo : Hugo markdown ( using shortcodes ) # Weave.list_out_formats \u2014 Method . list_out_formats() List supported output formats source Document syntax Weave uses noweb, markdown or script syntax for defining the code chunks and documentation chunks. You can also weave Jupyter notebooks. The format is detected based on the file extension, but you can also set it manually using the informat parameter. The rules for autodetection are: ext == \".jl\" && return \"script\" ext == \".jmd\" && return \"markdown\" ext == \".ipynb\" && return \"notebook\" return \"noweb\" Noweb format Code chunks start with a line marked with <<>>= or <<options>>= and end with line marked with @ . The code between the start and end markers is executed and the output is captured to the output document. See chunk options . Documentation chunks Are the rest of the document (between @ and <<>>= lines and the first chunk be default) and can be written with several different markup languages. Sample document Markdown format Markdown code chunks are defined using fenced code blocks with options following on the same line. e.g. to hide code from output you can use: ```julia; echo=false See sample document: Script format Weave also support script input format with a markup in comments. These scripts can be executed normally using Julia or published with Weave. Documentation is in lines starting with #' , #%% or # %% , and code is executed and results are included in the weaved document. All lines that are not documentation are treated as code. You can set chunk options using lines starting with #+ just before code e.g. #+ term=true . The format is identical to Pweave and the concept is similar to publishing documents with MATLAB or using Knitr's spin . Weave will remove the first empty space from each line of documentation. See sample document: Inline code You can also add inline code to your documents using `j juliacode` syntax. The code will be replaced with the output of running the code. If the code produces figures the filename or base64 encoded string will be added to output e.g. to include a Plots figure in markdown you can use: ! [ A plot ]( ` j plot ( 1 : 10 ) ` ) Passing arguments to documents You can pass arguments as dictionary to the weaved document using the args argument to weave . The dictionary will be available as WEAVE_ARGS variable in the document. This makes it possible to create the same report easily for e.g. different date ranges of input data from a database or from files with similar format giving the filename as input. In order to pass a filename to a document you need call weave using: weave ( \"mydoc.jmd\" , args = Dict ( \"filename\" => \"somedata.h5\" )) and you can access the filename from document as follows: ```julia print(WEAVE_ARGS[\"filename\"]) ``` You can use the out_path argument to control the name of the output document. Include Weave document in Julia You can call include_weave on a Weave document to run the contents of all code chunks in Julia. # Weave.include_weave \u2014 Function . include_weave(doc, informat=:auto) Include code from Weave document calling include_string on all code from doc. Code is run in the path of the include document. source","title":"Using Weave"},{"location":"usage/#using-weave","text":"You can write your documentation and code in input document using Noweb, Markdown or script syntax and use weave function to execute to document to capture results and figures.","title":"Using Weave"},{"location":"usage/#weave","text":"Weave document with markup and julia code using Plots.jl for plots, out_path = :pwd makes the results appear in the current working directory. #First add depencies for the example using Pkg ; Pkg . add . ([ \"Plots\" , \"DSP\" ]) using Weave weave ( joinpath ( dirname ( pathof ( Weave )), \"../examples\" , \"FIR_design.jmd\" ), out_path =: pwd ) # Weave.weave \u2014 Method . weave(source ; doctype = :auto, informat=:auto, out_path=:doc, args = Dict(), mod::Union{Module, Symbol} = Main, fig_path = \"figures\", fig_ext = nothing, cache_path = \"cache\", cache=:off, template = nothing, highlight_theme = nothing, css = nothing, pandoc_options = \"\", latex_cmd = \"xelatex\") Weave an input document to output file. doctype : :auto = set based on file extension or specify one of the supported formats. See list_out_formats() informat : :auto = set based on file extension or set to \"noweb\" , \"markdown\" or script out_path : Path where the output is generated. Can be: :doc : Path of the source document, :pwd : Julia working directory, \"somepath\" : output directory as a String e.g \"/home/mpastell/weaveout\" or filename as string e.g. ~/outpath/outfile.tex. args : dictionary of arguments to pass to document. Available as WEAVE_ARGS mod : Module where Weave eval s code. Defaults to :sandbox to create new sandbox module, you can also pass a module e.g. Main . fig_path : where figures will be generated, relative to out_path fig_ext : Extension for saved figures e.g. \".pdf\" , \".png\" . Default setting depends on doctype . cache_path : where of cached output will be saved. cache : controls caching of code: :off = no caching, :all = cache everything, :user = cache based on chunk options, :refresh , run all code chunks and save new cache. throw_errors if false errors are included in output document and the whole document is executed. if true errors are thrown when they occur. template : Template (file path) for md2html or md2tex formats. highlight_theme : Theme (Highlights.AbstractTheme) for used syntax highlighting css : CSS (file path) used for md2html format pandoc_options = String array of options to pass to pandoc for pandoc2html and pandoc2pdf formats e.g. [\"\u2013toc\", \"-N\"] latex_cmd the command used to make pdf from .tex Note: Run Weave from terminal and not using IJulia, Juno or ESS, they tend to mess with capturing output. source","title":"Weave"},{"location":"usage/#tangle","text":"Tangling extracts the code from document: # Weave.tangle \u2014 Method . tangle(source ; out_path=:doc, informat=\"noweb\") Tangle source code from input document to .jl file. informat : \"noweb\" of \"markdown\" out_path : Path where the output is generated. Can be: :doc : Path of the source document, :pwd : Julia working directory, \"somepath\" , directory name as a string e.g \"/home/mpastell/weaveout\" or filename as string e.g. ~/outpath/outfile.jl. source","title":"Tangle"},{"location":"usage/#supported-formats","text":"Weave sets the output format based on the file extension, but you can also set it using doctype option. The rules for detecting the format are: ext == \".jl\" && return \"md2html\" contains ( ext , \".md\" ) && return \"md2html\" contains ( ext , \".rst\" ) && return \"rst\" contains ( ext , \".tex\" ) && return \"texminted\" contains ( ext , \".txt\" ) && return \"asciidoc\" return \"pandoc\" You can get a list of supported output formats: list_out_formats () github : Github markdown md2tex : Julia markdown to latex pandoc2html : Markdown to HTML ( requires Pandoc 2 ) pandoc : Pandoc markdown pandoc2pdf : Pandoc markdown tex : Latex with custom code environments texminted : Latex using minted for highlighting md2html : Julia markdown to html rst : reStructuredText and Sphinx multimarkdown : MultiMarkdown md2pdf : Julia markdown to latex asciidoc : AsciiDoc hugo : Hugo markdown ( using shortcodes ) # Weave.list_out_formats \u2014 Method . list_out_formats() List supported output formats source","title":"Supported formats"},{"location":"usage/#document-syntax","text":"Weave uses noweb, markdown or script syntax for defining the code chunks and documentation chunks. You can also weave Jupyter notebooks. The format is detected based on the file extension, but you can also set it manually using the informat parameter. The rules for autodetection are: ext == \".jl\" && return \"script\" ext == \".jmd\" && return \"markdown\" ext == \".ipynb\" && return \"notebook\" return \"noweb\"","title":"Document syntax"},{"location":"usage/#noweb-format","text":"","title":"Noweb format"},{"location":"usage/#code-chunks","text":"start with a line marked with <<>>= or <<options>>= and end with line marked with @ . The code between the start and end markers is executed and the output is captured to the output document. See chunk options .","title":"Code chunks"},{"location":"usage/#documentation-chunks","text":"Are the rest of the document (between @ and <<>>= lines and the first chunk be default) and can be written with several different markup languages. Sample document","title":"Documentation chunks"},{"location":"usage/#markdown-format","text":"Markdown code chunks are defined using fenced code blocks with options following on the same line. e.g. to hide code from output you can use: ```julia; echo=false See sample document:","title":"Markdown format"},{"location":"usage/#script-format","text":"Weave also support script input format with a markup in comments. These scripts can be executed normally using Julia or published with Weave. Documentation is in lines starting with #' , #%% or # %% , and code is executed and results are included in the weaved document. All lines that are not documentation are treated as code. You can set chunk options using lines starting with #+ just before code e.g. #+ term=true . The format is identical to Pweave and the concept is similar to publishing documents with MATLAB or using Knitr's spin . Weave will remove the first empty space from each line of documentation. See sample document:","title":"Script format"},{"location":"usage/#inline-code","text":"You can also add inline code to your documents using `j juliacode` syntax. The code will be replaced with the output of running the code. If the code produces figures the filename or base64 encoded string will be added to output e.g. to include a Plots figure in markdown you can use: ! [ A plot ]( ` j plot ( 1 : 10 ) ` )","title":"Inline code"},{"location":"usage/#passing-arguments-to-documents","text":"You can pass arguments as dictionary to the weaved document using the args argument to weave . The dictionary will be available as WEAVE_ARGS variable in the document. This makes it possible to create the same report easily for e.g. different date ranges of input data from a database or from files with similar format giving the filename as input. In order to pass a filename to a document you need call weave using: weave ( \"mydoc.jmd\" , args = Dict ( \"filename\" => \"somedata.h5\" )) and you can access the filename from document as follows: ```julia print(WEAVE_ARGS[\"filename\"]) ``` You can use the out_path argument to control the name of the output document.","title":"Passing arguments to documents"},{"location":"usage/#include-weave-document-in-julia","text":"You can call include_weave on a Weave document to run the contents of all code chunks in Julia. # Weave.include_weave \u2014 Function . include_weave(doc, informat=:auto) Include code from Weave document calling include_string on all code from doc. Code is run in the path of the include document. source","title":"Include Weave document in Julia"},{"location":"examples/FIR_design/","text":"Introduction This an example of a julia script that can be published using Weave . The script can be executed normally using Julia or published to HTML or pdf with Weave. Text is written in markdown in lines starting with \" #' \" and code is executed and results are included in the published document. Notice that you don't need to define chunk options, but you can using #+ . just before code e.g. #+ term=True, caption='Fancy plots.' . If you're viewing the published version have a look at the source to see the markup. FIR Filter Design We'll implement lowpass, highpass and ' bandpass FIR filters. If you want to read more about DSP I highly recommend The Scientist and Engineer's Guide to Digital Signal Processing which is freely available online. Calculating frequency response DSP.jl package doesn't (yet) have a method to calculate the the frequency response of a FIR filter so we define it: using Plots , DSP gr () function FIRfreqz ( b :: Array , w = range ( 0 , stop = \u03c0 , length = 1024 )) n = length ( w ) h = Array { ComplexF32 }( undef , n ) sw = 0 for i = 1 : n for j = 1 : length ( b ) sw += b [ j ] * exp ( - im * w [ i ]) ^- j end h [ i ] = sw sw = 0 end return h end ~~~~~~~~~~~~~ FIRfreqz (generic function with 2 methods) ~~~~ Design Lowpass FIR filter Designing a lowpass FIR filter is very simple to do with DSP.jl, all you need to do is to define the window length, cut off frequency and the window. We will define a lowpass filter with cut off frequency at 5Hz for a signal sampled at 20 Hz. We will use the Hamming window, which is defined as: $w(n) = \\alpha - \\beta\\cos\\frac{2\\pi n}{N-1}$, where $\\alpha=0.54$ and $\\beta=0.46$ ~~~~{.julia} fs = 20 f = digitalfilter(Lowpass(5, fs = fs), FIRWindow(hamming(61))) w = range(0, stop=pi, length=1024) h = FIRfreqz(f, w) ## Plot the frequency and impulse response The next code chunk is executed in term mode, see the [script](FIR_design.jl) for syntax. ~~~~{.julia} julia> h_db = log10.(abs.(h)); julia> ws = w/pi*(fs/2) 0.0:0.009775171065493646:10.0 ~~~~{.julia} plot(ws, h_db, xlabel = \"Frequency (Hz)\", ylabel = \"Magnitude (db)\") ![](figures/FIR_design_4_1.png)\\ And again with default options ~~~~{.julia} h_phase = unwrap(-atan.(imag.(h),real.(h))) plot(ws, h_phase, xlabel = \"Frequency (Hz)\", ylabel = \"Phase (radians)\") \\","title":"FIR filter design with Julia"},{"location":"examples/FIR_design/#introduction","text":"This an example of a julia script that can be published using Weave . The script can be executed normally using Julia or published to HTML or pdf with Weave. Text is written in markdown in lines starting with \" #' \" and code is executed and results are included in the published document. Notice that you don't need to define chunk options, but you can using #+ . just before code e.g. #+ term=True, caption='Fancy plots.' . If you're viewing the published version have a look at the source to see the markup.","title":"Introduction"},{"location":"examples/FIR_design/#fir-filter-design","text":"We'll implement lowpass, highpass and ' bandpass FIR filters. If you want to read more about DSP I highly recommend The Scientist and Engineer's Guide to Digital Signal Processing which is freely available online.","title":"FIR Filter Design"},{"location":"examples/FIR_design/#calculating-frequency-response","text":"DSP.jl package doesn't (yet) have a method to calculate the the frequency response of a FIR filter so we define it: using Plots , DSP gr () function FIRfreqz ( b :: Array , w = range ( 0 , stop = \u03c0 , length = 1024 )) n = length ( w ) h = Array { ComplexF32 }( undef , n ) sw = 0 for i = 1 : n for j = 1 : length ( b ) sw += b [ j ] * exp ( - im * w [ i ]) ^- j end h [ i ] = sw sw = 0 end return h end ~~~~~~~~~~~~~ FIRfreqz (generic function with 2 methods) ~~~~","title":"Calculating frequency response"},{"location":"examples/FIR_design/#design-lowpass-fir-filter","text":"Designing a lowpass FIR filter is very simple to do with DSP.jl, all you need to do is to define the window length, cut off frequency and the window. We will define a lowpass filter with cut off frequency at 5Hz for a signal sampled at 20 Hz. We will use the Hamming window, which is defined as: $w(n) = \\alpha - \\beta\\cos\\frac{2\\pi n}{N-1}$, where $\\alpha=0.54$ and $\\beta=0.46$ ~~~~{.julia} fs = 20 f = digitalfilter(Lowpass(5, fs = fs), FIRWindow(hamming(61))) w = range(0, stop=pi, length=1024) h = FIRfreqz(f, w) ## Plot the frequency and impulse response The next code chunk is executed in term mode, see the [script](FIR_design.jl) for syntax. ~~~~{.julia} julia> h_db = log10.(abs.(h)); julia> ws = w/pi*(fs/2) 0.0:0.009775171065493646:10.0 ~~~~{.julia} plot(ws, h_db, xlabel = \"Frequency (Hz)\", ylabel = \"Magnitude (db)\") ![](figures/FIR_design_4_1.png)\\ And again with default options ~~~~{.julia} h_phase = unwrap(-atan.(imag.(h),real.(h))) plot(ws, h_phase, xlabel = \"Frequency (Hz)\", ylabel = \"Phase (radians)\") \\","title":"Design Lowpass FIR filter"}]}