{
    "docs": [
        {
            "location": "/",
            "text": "Weave.jl - Scientific Reports Using Julia\n\n\nThis is the documentation of \nWeave.jl\n. Weave is a scientific report generator/literate programming tool for Julia. It resembles \nPweave\n, Knitr, rmarkdown and Sweave.\n\n\nCurrent features\n\n\n\n\nNoweb, markdown or script syntax for input documents.\n\n\nExecute code as terminal or \"script\" chunks.\n\n\nCapture Plots, Gadfly and PyPlot figures.\n\n\nSupports LaTex, Pandoc, Github markdown, MultiMarkdown, Asciidoc and reStructuredText output\n\n\nPublish markdown directly to html and pdf using julia or Pandoc markdown.\n\n\nSimple caching of results\n\n\nConvert to and from IJulia notebooks\n\n\n\n\n\n\n\n\nContents\n\n\n\n\nGetting started\n\n\nUsing Weave\n\n\nWeave\n\n\nWeave from shell\n\n\nTangle\n\n\nSupported formats\n\n\nDocument syntax\n\n\nNoweb format\n\n\nMarkdown format\n\n\nScript format\n\n\nInline code\n\n\nPassing arguments to documents\n\n\nInclude Weave document in Julia\n\n\n\n\n\n\nPublishing to html and pdf\n\n\nTemplates\n\n\n\n\n\n\nChunk options\n\n\nOptions for code\n\n\nOptions for figures\n\n\nSet default chunk options\n\n\n\n\n\n\nWorking with Jupyter notebooks\n\n\nWeaving from Jupyter notebooks\n\n\nOutput to Jupyter notebooks\n\n\nConverting between formats\n\n\n\n\n\n\nFunction index",
            "title": "Home"
        },
        {
            "location": "/#weavejl-scientific-reports-using-julia",
            "text": "This is the documentation of  Weave.jl . Weave is a scientific report generator/literate programming tool for Julia. It resembles  Pweave , Knitr, rmarkdown and Sweave.  Current features   Noweb, markdown or script syntax for input documents.  Execute code as terminal or \"script\" chunks.  Capture Plots, Gadfly and PyPlot figures.  Supports LaTex, Pandoc, Github markdown, MultiMarkdown, Asciidoc and reStructuredText output  Publish markdown directly to html and pdf using julia or Pandoc markdown.  Simple caching of results  Convert to and from IJulia notebooks",
            "title": "Weave.jl - Scientific Reports Using Julia"
        },
        {
            "location": "/#contents",
            "text": "Getting started  Using Weave  Weave  Weave from shell  Tangle  Supported formats  Document syntax  Noweb format  Markdown format  Script format  Inline code  Passing arguments to documents  Include Weave document in Julia    Publishing to html and pdf  Templates    Chunk options  Options for code  Options for figures  Set default chunk options    Working with Jupyter notebooks  Weaving from Jupyter notebooks  Output to Jupyter notebooks  Converting between formats    Function index",
            "title": "Contents"
        },
        {
            "location": "/getting_started/",
            "text": "Getting started\n\n\nThe best way to get started using Weave.jl is to look at the example input and output documents. Examples for different formats are included in the packages \nexamples\n directory.\n\n\nFirst have a look at source document using markdown code chunks and Gadfly for figures: \ngadfly_md_sample.jmd\n and then see the output in different formats:\n\n\n\n\nPandoc markdown: \ngadfly_md_sample.md\n\n\nHTML: \ngadfly_md_sample.html\n\n\npdf: \ngadfly_md_sample.pdf\n\n\n\n\nProducing pdf output requires that you have pdflatex installed.\n\n\nAdd depencies for the example if needed:\n\n\nPkg\n.\nadd\n.\n([\n\"Cairo\"\n,\n \n\"Fontconfig\"\n,\n \n\"Gadfly\"\n])\n\n\n\n\n\n\nWeave the files to your working directory using:\n\n\nusing\n \nWeave\n\n\n#Markdown\n\n\nweave\n(\nPkg\n.\ndir\n(\n\"Weave\"\n,\n\"examples\"\n,\n\"gadfly_md_sample.jmd\"\n),\n \nout_path\n \n=\n \n:\npwd\n,\n\n  \ndoctype\n \n=\n \n\"pandoc\"\n)\n\n\n#HTML\n\n\nweave\n(\nPkg\n.\ndir\n(\n\"Weave\"\n,\n\"examples\"\n,\n\"gadfly_md_sample.jmd\"\n),\n \nout_path\n \n=\n \n:\npwd\n,\n\n  \ndoctype\n \n=\n \n\"md2html\"\n)\n\n\n#pdf\n\n\nweave\n(\nPkg\n.\ndir\n(\n\"Weave\"\n,\n\"examples\"\n,\n\"gadfly_md_sample.jmd\"\n),\n \nout_path\n \n=\n \n:\npwd\n,\n\n  \ndoctype\n \n=\n \n\"md2pdf\"\n)",
            "title": "Getting started"
        },
        {
            "location": "/getting_started/#getting-started",
            "text": "The best way to get started using Weave.jl is to look at the example input and output documents. Examples for different formats are included in the packages  examples  directory.  First have a look at source document using markdown code chunks and Gadfly for figures:  gadfly_md_sample.jmd  and then see the output in different formats:   Pandoc markdown:  gadfly_md_sample.md  HTML:  gadfly_md_sample.html  pdf:  gadfly_md_sample.pdf   Producing pdf output requires that you have pdflatex installed.  Add depencies for the example if needed:  Pkg . add . ([ \"Cairo\" ,   \"Fontconfig\" ,   \"Gadfly\" ])   Weave the files to your working directory using:  using   Weave  #Markdown  weave ( Pkg . dir ( \"Weave\" , \"examples\" , \"gadfly_md_sample.jmd\" ),   out_path   =   : pwd , \n   doctype   =   \"pandoc\" )  #HTML  weave ( Pkg . dir ( \"Weave\" , \"examples\" , \"gadfly_md_sample.jmd\" ),   out_path   =   : pwd , \n   doctype   =   \"md2html\" )  #pdf  weave ( Pkg . dir ( \"Weave\" , \"examples\" , \"gadfly_md_sample.jmd\" ),   out_path   =   : pwd , \n   doctype   =   \"md2pdf\" )",
            "title": "Getting started"
        },
        {
            "location": "/usage/",
            "text": "Using Weave\n\n\nYou can write your documentation and code in input document using Noweb, Markdown or script syntax and use \nweave\n function to execute to document to capture results and figures.\n\n\n\n\nWeave\n\n\nWeave document with markup and julia code using Gadfly for plots, \nout_path = :pwd\n makes the results appear in the current working directory.\n\n\nusing\n \nWeave\n\n\nweave\n(\nPkg\n.\ndir\n(\n\"Weave\"\n,\n\"examples\"\n,\n\"gadfly_sample.mdw\"\n),\n \nout_path\n \n=\n \n:\npwd\n)\n\n\n\n\n\n\nUsing PyPlot:\n\n\nweave\n(\nPkg\n.\ndir\n(\n\"Weave\"\n,\n\"examples\"\n,\n\"julia_sample.mdw\"\n),\n \nplotlib\n=\n\"PyPlot\"\n,\n \nout_path\n \n=\n \n:\npwd\n)\n\n\n\n\n\n\n#\n\n\nWeave.weave\n \u2014 \nMethod\n.\n\n\nweave(source ; doctype = :auto, plotlib=:auto,\n    informat=:auto, out_path=:doc, args = Dict(),\n    fig_path = \"figures\", fig_ext = nothing,\n    cache_path = \"cache\", cache=:off,\n    template = nothing, highlight_theme = nothing, css = nothing\n    latex_cmd = \"xelatex\")\n\n\n\n\n\nWeave an input document to output file.\n\n\n\n\ndoctype\n: :auto = set based on file extension or specify one of the supported formats. See \nlist_out_formats()\n\n\nplotlib\n: \n\"PyPlot\"\n, \n\"Gadfly\"\n or \nnothing\n\n\ninformat\n: :auto = set based on file extension or set to  \n\"noweb\"\n, \n\"markdown\"\n or  \nscript\n\n\nout_path\n: Path where the output is generated. Can be: \n:doc\n: Path of the source document, \n:pwd\n:  Julia working directory, \n\"somepath\"\n: output directory as a String e.g \n\"/home/mpastell/weaveout\"\n or filename as  string e.g. ~/outpath/outfile.tex.\n\n\nargs\n: dictionary of arguments to pass to document. Available as WEAVE_ARGS\n\n\nfig_path\n: where figures will be generated, relative to out_path\n\n\nfig_ext\n: Extension for saved figures e.g. \n\".pdf\"\n, \n\".png\"\n. Default setting depends on \ndoctype\n.\n\n\ncache_path\n: where of cached output will be saved.\n\n\ncache\n: controls caching of code: \n:off\n = no caching, \n:all\n = cache everything, \n:user\n = cache based on chunk options, \n:refresh\n, run all code chunks and save new cache.\n\n\nthrow_errors\n if \nfalse\n errors are included in output document and the whole document is    executed. if \ntrue\n errors are thrown when they occur.\n\n\ntemplate\n : Template (file path) for md2html or md2tex formats.\n\n\nhighlight_theme\n : Theme (Highlights.AbstractTheme) for used syntax highlighting\n\n\ncss\n : CSS (file path) used for md2html format\n\n\nlatex_cmd\n the command used to make pdf from .tex\n\n\n\n\nNote:\n Run Weave from terminal and not using IJulia, Juno or ESS, they tend to mess with capturing output.\n\n\nsource\n\n\n\n\nWeave from shell\n\n\nYou can also use the \nweave.jl\n script under bin directory to weave documents from the shell:\n\n\n$ ./weave.jl\nusage: weave.jl \n[\n--doctype DOCTYPE\n]\n \n[\n--plotlib PLOTLIB\n]\n\n                \n[\n--informat INFORMAT\n]\n \n[\n--out_path OUT_PATH\n]\n\n                \n[\n--fig_path FIG_PATH\n]\n \n[\n--fig_ext FIG_EXT\n]\n source...\n\n\n\n\n\n\n\nTangle\n\n\nTangling extracts the code from document:\n\n\n#\n\n\nWeave.tangle\n \u2014 \nMethod\n.\n\n\ntangle(source ; out_path=:doc, informat=\"noweb\")\n\n\nTangle source code from input document to .jl file.\n\n\n\n\ninformat\n: \n\"noweb\"\n of \n\"markdown\"\n\n\nout_path\n: Path where the output is generated. Can be: \n:doc\n: Path of the source document, \n:pwd\n: Julia working directory,  \n\"somepath\"\n, directory name as a string e.g \n\"/home/mpastell/weaveout\"\n\n\n\n\nor filename as string e.g. ~/outpath/outfile.jl.\n\n\nsource\n\n\n\n\nSupported formats\n\n\nWeave sets the output format based on the file extension, but you can also set it using \ndoctype\n option. The rules for detecting the format are:\n\n\next\n \n==\n \n\".jl\"\n \n&&\n \nreturn\n \n\"md2html\"\n\n\ncontains\n(\next\n,\n \n\".md\"\n)\n \n&&\n \nreturn\n \n\"md2html\"\n\n\ncontains\n(\next\n,\n \n\".rst\"\n)\n \n&&\n \nreturn\n \n\"rst\"\n\n\ncontains\n(\next\n,\n \n\".tex\"\n)\n \n&&\n \nreturn\n \n\"texminted\"\n\n\ncontains\n(\next\n,\n \n\".txt\"\n)\n \n&&\n \nreturn\n \n\"asciidoc\"\n\n\nreturn\n \n\"pandoc\"\n\n\n\n\n\n\nYou can get a list of supported output formats:\n\n\nlist_out_formats\n()\n\n\n\n\n\n\ngithub\n:\n \nGithub\n \nmarkdown\n\n\nmd2tex\n:\n \nJulia\n \nmarkdown\n \nto\n \nlatex\n\n\npandoc2html\n:\n \nMarkdown\n \nto\n \nHTML\n \n(\nrequires\n \nPandoc\n)\n\n\npandoc\n:\n \nPandoc\n \nmarkdown\n\n\npandoc2pdf\n:\n \nPandoc\n \nmarkdown\n\n\ntex\n:\n \nLatex\n \nwith\n \ncustom\n \ncode\n \nenvironments\n\n\ntexminted\n:\n \nLatex\n \nusing\n \nminted\n \nfor\n \nhighlighting\n\n\nmd2html\n:\n \nJulia\n \nmarkdown\n \nto\n \nhtml\n\n\nrst\n:\n \nreStructuredText\n \nand\n \nSphinx\n\n\nmultimarkdown\n:\n \nMultiMarkdown\n\n\nmd2pdf\n:\n \nJulia\n \nmarkdown\n \nto\n \nlatex\n\n\nasciidoc\n:\n \nAsciiDoc\n\n\nhugo\n:\n \nHugo\n \nmarkdown\n \n(\nusing\n \nshortcodes\n)\n\n\n\n\n\n\n#\n\n\nWeave.list_out_formats\n \u2014 \nMethod\n.\n\n\nlist_out_formats()\n\n\nList supported output formats\n\n\nsource\n\n\n\n\nDocument syntax\n\n\nWeave uses noweb, markdown or script syntax for defining the code chunks and documentation chunks. You can also weave Jupyter notebooks. The format is detected based on the file extension, but you can also set it manually using the \ninformat\n parameter.\n\n\nThe rules for autodetection are:\n\n\next\n \n==\n \n\".jl\"\n \n&&\n \nreturn\n \n\"script\"\n\n\next\n \n==\n \n\".jmd\"\n \n&&\n \nreturn\n \n\"markdown\"\n\n\next\n \n==\n \n\".ipynb\"\n \n&&\n \nreturn\n \n\"notebook\"\n\n\nreturn\n \n\"noweb\"\n\n\n\n\n\n\n\n\nNoweb format\n\n\n\n\nCode chunks\n\n\nstart with a line marked with \n<<>>=\n or \n<<options>>=\n and end with line marked with \n@\n. The code between the start and end markers is executed and the output is captured to the output document. See \nchunk options\n.\n\n\n\n\nDocumentation chunks\n\n\nAre the rest of the document (between \n@\n and \n<<>>=\n lines and the first chunk be default) and can be written with several different markup languages.\n\n\nSample document\n\n\n\n\nMarkdown format\n\n\nMarkdown code chunks are defined using fenced code blocks with options following on the same line. e.g. to hide code from output you can use:\n\n\n```julia; echo=false\n\n\nSee sample document:\n\n\n\n\nScript format\n\n\nWeave also support script input format with a markup in comments. These scripts can be executed normally using Julia or published with Weave.  Documentation is in lines starting with \n#'\n, \n#%%\n or \n# %%\n, and code is executed and results are included in the weaved document.\n\n\nAll lines that are not documentation are treated as code. You can set chunk options using lines starting with \n#+\n just before code e.g. \n#+ term=true\n.\n\n\nThe format is identical to \nPweave\n and the concept is similar to publishing documents with MATLAB or using Knitr's \nspin\n. Weave will remove the first empty space from each line of documentation.\n\n\nSee sample document:\n\n\n\n\nInline code\n\n\nYou can also add inline code to your documents using\n\n\n`j juliacode`\n\n\n\n\n\nsyntax. The code will be replaced with the output of running the code.  If the code produces figures the filename or base64 encoded string will be  added to output e.g. to include a Plots figure in markdown you can use:\n\n\n!\n[\nA\n \nplot\n](\n`\nj\n \nplot\n(\n1\n:\n10\n)\n`\n)\n\n\n\n\n\n\n\n\nPassing arguments to documents\n\n\nYou can pass arguments as dictionary to the weaved document using the \nargs\n argument  to \nweave\n. The dictionary will be available as \nWEAVE_ARGS\n variable in the document.\n\n\nThis makes it possible to create the same report easily for e.g. different  date ranges of input data from a database or from files with similar format giving the filename as input. \n\n\nIn order to pass a filename to a document you need call \nweave\n using:\n\n\nweave\n(\n\"mydoc.jmd\"\n,\n \nargs\n \n=\n \nDict\n(\n\"filename\"\n \n=>\n \n\"somedata.h5\"\n))\n\n\n\n\n\n\nand you can access the filename from document as follows:\n\n\n ```julia\n print(WEAVE_ARGS[\"filename\"])\n ```\n\n\n\n\n\nYou can use the \nout_path\n argument to control the name of the  output document.\n\n\n\n\nInclude Weave document in Julia\n\n\nYou can call \ninclude_weave\n on a Weave document to run the contents of all code chunks in Julia.\n\n\n#\n\n\nWeave.include_weave\n \u2014 \nFunction\n.\n\n\ninclude_weave(doc, informat=:auto)\n\n\n\n\n\nInclude code from Weave document calling \ninclude_string\n on all code from doc. Code is run in the path of the include document.\n\n\nsource",
            "title": "Using Weave"
        },
        {
            "location": "/usage/#using-weave",
            "text": "You can write your documentation and code in input document using Noweb, Markdown or script syntax and use  weave  function to execute to document to capture results and figures.",
            "title": "Using Weave"
        },
        {
            "location": "/usage/#weave",
            "text": "Weave document with markup and julia code using Gadfly for plots,  out_path = :pwd  makes the results appear in the current working directory.  using   Weave  weave ( Pkg . dir ( \"Weave\" , \"examples\" , \"gadfly_sample.mdw\" ),   out_path   =   : pwd )   Using PyPlot:  weave ( Pkg . dir ( \"Weave\" , \"examples\" , \"julia_sample.mdw\" ),   plotlib = \"PyPlot\" ,   out_path   =   : pwd )   #  Weave.weave  \u2014  Method .  weave(source ; doctype = :auto, plotlib=:auto,\n    informat=:auto, out_path=:doc, args = Dict(),\n    fig_path = \"figures\", fig_ext = nothing,\n    cache_path = \"cache\", cache=:off,\n    template = nothing, highlight_theme = nothing, css = nothing\n    latex_cmd = \"xelatex\")  Weave an input document to output file.   doctype : :auto = set based on file extension or specify one of the supported formats. See  list_out_formats()  plotlib :  \"PyPlot\" ,  \"Gadfly\"  or  nothing  informat : :auto = set based on file extension or set to   \"noweb\" ,  \"markdown\"  or   script  out_path : Path where the output is generated. Can be:  :doc : Path of the source document,  :pwd :  Julia working directory,  \"somepath\" : output directory as a String e.g  \"/home/mpastell/weaveout\"  or filename as  string e.g. ~/outpath/outfile.tex.  args : dictionary of arguments to pass to document. Available as WEAVE_ARGS  fig_path : where figures will be generated, relative to out_path  fig_ext : Extension for saved figures e.g.  \".pdf\" ,  \".png\" . Default setting depends on  doctype .  cache_path : where of cached output will be saved.  cache : controls caching of code:  :off  = no caching,  :all  = cache everything,  :user  = cache based on chunk options,  :refresh , run all code chunks and save new cache.  throw_errors  if  false  errors are included in output document and the whole document is    executed. if  true  errors are thrown when they occur.  template  : Template (file path) for md2html or md2tex formats.  highlight_theme  : Theme (Highlights.AbstractTheme) for used syntax highlighting  css  : CSS (file path) used for md2html format  latex_cmd  the command used to make pdf from .tex   Note:  Run Weave from terminal and not using IJulia, Juno or ESS, they tend to mess with capturing output.  source",
            "title": "Weave"
        },
        {
            "location": "/usage/#weave-from-shell",
            "text": "You can also use the  weave.jl  script under bin directory to weave documents from the shell:  $ ./weave.jl\nusage: weave.jl  [ --doctype DOCTYPE ]   [ --plotlib PLOTLIB ] \n                 [ --informat INFORMAT ]   [ --out_path OUT_PATH ] \n                 [ --fig_path FIG_PATH ]   [ --fig_ext FIG_EXT ]  source...",
            "title": "Weave from shell"
        },
        {
            "location": "/usage/#tangle",
            "text": "Tangling extracts the code from document:  #  Weave.tangle  \u2014  Method .  tangle(source ; out_path=:doc, informat=\"noweb\")  Tangle source code from input document to .jl file.   informat :  \"noweb\"  of  \"markdown\"  out_path : Path where the output is generated. Can be:  :doc : Path of the source document,  :pwd : Julia working directory,   \"somepath\" , directory name as a string e.g  \"/home/mpastell/weaveout\"   or filename as string e.g. ~/outpath/outfile.jl.  source",
            "title": "Tangle"
        },
        {
            "location": "/usage/#supported-formats",
            "text": "Weave sets the output format based on the file extension, but you can also set it using  doctype  option. The rules for detecting the format are:  ext   ==   \".jl\"   &&   return   \"md2html\"  contains ( ext ,   \".md\" )   &&   return   \"md2html\"  contains ( ext ,   \".rst\" )   &&   return   \"rst\"  contains ( ext ,   \".tex\" )   &&   return   \"texminted\"  contains ( ext ,   \".txt\" )   &&   return   \"asciidoc\"  return   \"pandoc\"   You can get a list of supported output formats:  list_out_formats ()   github :   Github   markdown  md2tex :   Julia   markdown   to   latex  pandoc2html :   Markdown   to   HTML   ( requires   Pandoc )  pandoc :   Pandoc   markdown  pandoc2pdf :   Pandoc   markdown  tex :   Latex   with   custom   code   environments  texminted :   Latex   using   minted   for   highlighting  md2html :   Julia   markdown   to   html  rst :   reStructuredText   and   Sphinx  multimarkdown :   MultiMarkdown  md2pdf :   Julia   markdown   to   latex  asciidoc :   AsciiDoc  hugo :   Hugo   markdown   ( using   shortcodes )   #  Weave.list_out_formats  \u2014  Method .  list_out_formats()  List supported output formats  source",
            "title": "Supported formats"
        },
        {
            "location": "/usage/#document-syntax",
            "text": "Weave uses noweb, markdown or script syntax for defining the code chunks and documentation chunks. You can also weave Jupyter notebooks. The format is detected based on the file extension, but you can also set it manually using the  informat  parameter.  The rules for autodetection are:  ext   ==   \".jl\"   &&   return   \"script\"  ext   ==   \".jmd\"   &&   return   \"markdown\"  ext   ==   \".ipynb\"   &&   return   \"notebook\"  return   \"noweb\"",
            "title": "Document syntax"
        },
        {
            "location": "/usage/#noweb-format",
            "text": "",
            "title": "Noweb format"
        },
        {
            "location": "/usage/#code-chunks",
            "text": "start with a line marked with  <<>>=  or  <<options>>=  and end with line marked with  @ . The code between the start and end markers is executed and the output is captured to the output document. See  chunk options .",
            "title": "Code chunks"
        },
        {
            "location": "/usage/#documentation-chunks",
            "text": "Are the rest of the document (between  @  and  <<>>=  lines and the first chunk be default) and can be written with several different markup languages.  Sample document",
            "title": "Documentation chunks"
        },
        {
            "location": "/usage/#markdown-format",
            "text": "Markdown code chunks are defined using fenced code blocks with options following on the same line. e.g. to hide code from output you can use:  ```julia; echo=false  See sample document:",
            "title": "Markdown format"
        },
        {
            "location": "/usage/#script-format",
            "text": "Weave also support script input format with a markup in comments. These scripts can be executed normally using Julia or published with Weave.  Documentation is in lines starting with  #' ,  #%%  or  # %% , and code is executed and results are included in the weaved document.  All lines that are not documentation are treated as code. You can set chunk options using lines starting with  #+  just before code e.g.  #+ term=true .  The format is identical to  Pweave  and the concept is similar to publishing documents with MATLAB or using Knitr's  spin . Weave will remove the first empty space from each line of documentation.  See sample document:",
            "title": "Script format"
        },
        {
            "location": "/usage/#inline-code",
            "text": "You can also add inline code to your documents using  `j juliacode`  syntax. The code will be replaced with the output of running the code.  If the code produces figures the filename or base64 encoded string will be  added to output e.g. to include a Plots figure in markdown you can use:  ! [ A   plot ]( ` j   plot ( 1 : 10 ) ` )",
            "title": "Inline code"
        },
        {
            "location": "/usage/#passing-arguments-to-documents",
            "text": "You can pass arguments as dictionary to the weaved document using the  args  argument  to  weave . The dictionary will be available as  WEAVE_ARGS  variable in the document.  This makes it possible to create the same report easily for e.g. different  date ranges of input data from a database or from files with similar format giving the filename as input.   In order to pass a filename to a document you need call  weave  using:  weave ( \"mydoc.jmd\" ,   args   =   Dict ( \"filename\"   =>   \"somedata.h5\" ))   and you can access the filename from document as follows:   ```julia\n print(WEAVE_ARGS[\"filename\"])\n ```  You can use the  out_path  argument to control the name of the  output document.",
            "title": "Passing arguments to documents"
        },
        {
            "location": "/usage/#include-weave-document-in-julia",
            "text": "You can call  include_weave  on a Weave document to run the contents of all code chunks in Julia.  #  Weave.include_weave  \u2014  Function .  include_weave(doc, informat=:auto)  Include code from Weave document calling  include_string  on all code from doc. Code is run in the path of the include document.  source",
            "title": "Include Weave document in Julia"
        },
        {
            "location": "/publish/",
            "text": "Publishing to html and pdf\n\n\nYou can also publish any supported input format using markdown for doc chunks to html and pdf documents. Producing pdf output requires that you have pdflatex installed and in your path. \nThe markdown variant is \nJulia markdown\n.\n\n\nYou can use a YAML header in the beginning of the input document delimited with \"\u2013-\" to set the document title, author and date e.g.\n\n\n---\ntitle : Weave example\nauthor : Matti Pastell\ndate: 15th December 2016\n---\n\n\n\n\n\nHere is a a sample document and output:\n\n\nFIR_design.jl\n, \nFIR_design.html\n , \nFIR_design.pdf\n.\n\n\nweave\n(\n\"FIR_design.jl\"\n)\n\n\nweave\n(\n\"FIR_design.jl\"\n,\n \ndocformat\n \n=\n \n\"md2pdf\"\n)\n\n\n\n\n\n\nNote:\n docformats \nmd2pdf\n and \nmd2html\n use Julia markdown and \npandoc2pdf\n and \npandoc2html\n use Pandoc.\n\n\n\n\nTemplates\n\n\nYou can use a custom template with \nmd2pdf\n and \nmd2html\n formats with \ntemplate\n argument (e.g) \nweave(\"FIR_design.jl\", template = \"custom.tpl\"\n). You can use the existing templates as starting point.\n\n\nFor HTML: \njulia_html.tpl\n and LaTex: \njulia_tex.tpl\n\n\nTemplates are rendered using \nMustache.jl\n.",
            "title": "Publishing scripts"
        },
        {
            "location": "/publish/#publishing-to-html-and-pdf",
            "text": "You can also publish any supported input format using markdown for doc chunks to html and pdf documents. Producing pdf output requires that you have pdflatex installed and in your path.  The markdown variant is  Julia markdown .  You can use a YAML header in the beginning of the input document delimited with \"\u2013-\" to set the document title, author and date e.g.  ---\ntitle : Weave example\nauthor : Matti Pastell\ndate: 15th December 2016\n---  Here is a a sample document and output:  FIR_design.jl ,  FIR_design.html  ,  FIR_design.pdf .  weave ( \"FIR_design.jl\" )  weave ( \"FIR_design.jl\" ,   docformat   =   \"md2pdf\" )   Note:  docformats  md2pdf  and  md2html  use Julia markdown and  pandoc2pdf  and  pandoc2html  use Pandoc.",
            "title": "Publishing to html and pdf"
        },
        {
            "location": "/publish/#templates",
            "text": "You can use a custom template with  md2pdf  and  md2html  formats with  template  argument (e.g)  weave(\"FIR_design.jl\", template = \"custom.tpl\" ). You can use the existing templates as starting point.  For HTML:  julia_html.tpl  and LaTex:  julia_tex.tpl  Templates are rendered using  Mustache.jl .",
            "title": "Templates"
        },
        {
            "location": "/chunk_options/",
            "text": "Chunk options\n\n\nI've mostly followed \nKnitr\n's naming for chunk options, but not all options are implemented.\n\n\nOptions are separated using \";\" and need to be valid Julia expressions. Example: A code chunk that saves and displays a 12 cm wide image and hides the source code:\n\n\n<<\nfig_width\n=\n5\n;\n \necho\n=\nfalse\n \n>>=\n\n\nusing\n \nGadfly\n\n\nx\n \n=\n \nlinspace\n(\n0\n,\n \n2\n\u03c0\n,\n \n200\n)\n\n\nplot\n(\nx\n=\nx\n,\n \ny\n \n=\n \nsin\n(\nx\n),\n \nGeom\n.\nline\n)\n\n\n@\n\n\n\n\n\n\nWeave currently supports the following chunk options with the following defaults:\n\n\n\n\nOptions for code\n\n\n\n\necho = true\n. Echo the code in the output document. If \nfalse\n the source code will be hidden.\n\n\nresults = \"markup\"\n. The output format of the printed results. \"markup\" for literal block, \"hidden\" for hidden results or anything else for raw output (I tend to use \u2018tex\u2019 for Latex and \u2018rst\u2019 for rest. Raw output is useful if you wan\u2019t to e.g. create tables from code chunks.\n\n\neval = true\n. Evaluate the code chunk. If false the chunk won\u2019t be executed.\n\n\nterm=false\n. If true the output emulates a REPL session. Otherwise only stdout and figures will be included in output.\n\n\nlabel\n. Chunk label, will be used for figure labels in Latex as fig:label\n\n\nwrap = true\n. Wrap long lines from output.\n\n\nline_width = 75\n. Line width for wrapped lines.\n\n\ncache = false\n. Cache results, depends on \ncache\n parameter on \nweave\n function.\n\n\nhold = false\n. Hold all results until the end of the chunk.\n\n\ntangle = true\n. Set tangle to false to exclude chunk from tangled code.\n\n\n\n\n\n\nOptions for figures\n\n\n\n\nfig_width\n. Figure width defined in markup, default depends on the output format.\n\n\nout_width\n. Width of saved figure.\n\n\nout_height\n. Height of saved figure.\n\n\ndpi\n=96. Resolution of saved figures.\n\n\nfig_cap\n. Figure caption.\n\n\nlabel\n. Chunk label, will be used for figure labels in Latex as fig:label\n\n\nfig_ext\n. File extension (format) of saved figures.\n\n\nfig_pos=\"htpb\"\n. Figure position in Latex.\n\n\nfig_env=\"figure\"\n. Figure environment in Latex.\n\n\n\n\n\n\nSet default chunk options\n\n\nYou can set or alter the default chunk options for a document either before running weave or inside the weaved document. You can e.g. use a hidden chunk in the beginning of the source document to set the options:\n\n\n<<\necho\n \n=\n \nfalse\n>>=\n\n\nimport\n \nWeave\n\n\nWeave\n.\nset_chunk_defaults\n(\nDict\n{\nSymbol\n,\n \nAny\n}(\n\n      \n:\nout_width\n \n=>\n \n\"\n\\\\\n0.5linewidth\"\n,\n\n      \n:\nresults\n \n=>\n \n\"tex\"\n\n      \n))\n\n\n@\n\n\n\n\n\n\nset_chunk_defaults(opts)\nget_chunk_defaults()\nrestore_chunk_defaults()",
            "title": "Chunk options"
        },
        {
            "location": "/chunk_options/#chunk-options",
            "text": "I've mostly followed  Knitr 's naming for chunk options, but not all options are implemented.  Options are separated using \";\" and need to be valid Julia expressions. Example: A code chunk that saves and displays a 12 cm wide image and hides the source code:  << fig_width = 5 ;   echo = false   >>=  using   Gadfly  x   =   linspace ( 0 ,   2 \u03c0 ,   200 )  plot ( x = x ,   y   =   sin ( x ),   Geom . line )  @   Weave currently supports the following chunk options with the following defaults:",
            "title": "Chunk options"
        },
        {
            "location": "/chunk_options/#options-for-code",
            "text": "echo = true . Echo the code in the output document. If  false  the source code will be hidden.  results = \"markup\" . The output format of the printed results. \"markup\" for literal block, \"hidden\" for hidden results or anything else for raw output (I tend to use \u2018tex\u2019 for Latex and \u2018rst\u2019 for rest. Raw output is useful if you wan\u2019t to e.g. create tables from code chunks.  eval = true . Evaluate the code chunk. If false the chunk won\u2019t be executed.  term=false . If true the output emulates a REPL session. Otherwise only stdout and figures will be included in output.  label . Chunk label, will be used for figure labels in Latex as fig:label  wrap = true . Wrap long lines from output.  line_width = 75 . Line width for wrapped lines.  cache = false . Cache results, depends on  cache  parameter on  weave  function.  hold = false . Hold all results until the end of the chunk.  tangle = true . Set tangle to false to exclude chunk from tangled code.",
            "title": "Options for code"
        },
        {
            "location": "/chunk_options/#options-for-figures",
            "text": "fig_width . Figure width defined in markup, default depends on the output format.  out_width . Width of saved figure.  out_height . Height of saved figure.  dpi =96. Resolution of saved figures.  fig_cap . Figure caption.  label . Chunk label, will be used for figure labels in Latex as fig:label  fig_ext . File extension (format) of saved figures.  fig_pos=\"htpb\" . Figure position in Latex.  fig_env=\"figure\" . Figure environment in Latex.",
            "title": "Options for figures"
        },
        {
            "location": "/chunk_options/#set-default-chunk-options",
            "text": "You can set or alter the default chunk options for a document either before running weave or inside the weaved document. You can e.g. use a hidden chunk in the beginning of the source document to set the options:  << echo   =   false >>=  import   Weave  Weave . set_chunk_defaults ( Dict { Symbol ,   Any }( \n       : out_width   =>   \" \\\\ 0.5linewidth\" , \n       : results   =>   \"tex\" \n       ))  @   set_chunk_defaults(opts)\nget_chunk_defaults()\nrestore_chunk_defaults()",
            "title": "Set default chunk options"
        },
        {
            "location": "/notebooks/",
            "text": "Working with Jupyter notebooks\n\n\n\n\nWeaving from Jupyter notebooks\n\n\nWeave supports using Jupyter notebooks as input format, this means you can weave notebooks to any supported formats. You can't use chunk options with notebooks.\n\n\nweave\n(\n\"notebook.ipynb\"\n)\n\n\n\n\n\n\n\n\nOutput to Jupyter notebooks\n\n\nAs of Weave 0.5.1. there is new \nnotebook\n method to convert Weave documents to Jupyter notebooks using \nnbconvert\n. The code \nis not executed by Weave\n  and the output doesn't always work properly,  see \n#116\n.\n\n\n#\n\n\nWeave.notebook\n \u2014 \nFunction\n.\n\n\nnotebook(source::String, out_path=:pwd)\n\n\nConvert Weave document \nsource\n to Jupyter notebook and execute the code  using nbconvert. You need to have nbconvert installed and in your  path. \nIgnores\n all chunk options.\n\n\n\n\nout_path\n: Path where the output is generated. Can be: \n:doc\n: Path of the source document,   \n:pwd\n: Julia working directory, \n\"somepath\"\n: Path as a    String e.g \n\"/home/mpastell/weaveout\"\n\n\nnbconvert cell timeout in seconds. Defaults to -1 (no timeout)\n\n\n\n\nsource\n\n\nYou might wan't to use the \nconvert_doc\n method below instead and run the code in Jupyter.\n\n\n\n\nConverting between formats\n\n\nYou can convert between all supported input formats using the \nconvert_doc\n function.\n\n\nTo convert from script to notebook:\n\n\nconvert_doc\n(\n\"examples/FIR_design.jl\"\n,\n \n\"FIR_design.ipynb\"\n)\n\n\n\n\n\n\nand from notebooks to markdown use:\n\n\nconvert_doc\n(\n\"FIR_design.ipynb\"\n,\n \n\"FIR_design.jmd\"\n)\n\n\n\n\n\n\n#\n\n\nWeave.convert_doc\n \u2014 \nMethod\n.\n\n\nconvert_doc(infile::AbstractString, outfile::AbstractString; format = nothing)\n\n\nConvert Weave documents between different formats\n\n\n\n\ninfile\n = Name of the input document\n\n\noutfile\n = Name of the output document\n\n\nformat\n = Output format (optional). Detected from outfile extension, but can be set to \n\"script\"\n, \n\"markdown\"\n, \n\"notebook\"\n or \n\"noweb\"\n.\n\n\n\n\nsource",
            "title": "Working with Jupyter notebooks"
        },
        {
            "location": "/notebooks/#working-with-jupyter-notebooks",
            "text": "",
            "title": "Working with Jupyter notebooks"
        },
        {
            "location": "/notebooks/#weaving-from-jupyter-notebooks",
            "text": "Weave supports using Jupyter notebooks as input format, this means you can weave notebooks to any supported formats. You can't use chunk options with notebooks.  weave ( \"notebook.ipynb\" )",
            "title": "Weaving from Jupyter notebooks"
        },
        {
            "location": "/notebooks/#output-to-jupyter-notebooks",
            "text": "As of Weave 0.5.1. there is new  notebook  method to convert Weave documents to Jupyter notebooks using  nbconvert . The code  is not executed by Weave   and the output doesn't always work properly,  see  #116 .  #  Weave.notebook  \u2014  Function .  notebook(source::String, out_path=:pwd)  Convert Weave document  source  to Jupyter notebook and execute the code  using nbconvert. You need to have nbconvert installed and in your  path.  Ignores  all chunk options.   out_path : Path where the output is generated. Can be:  :doc : Path of the source document,    :pwd : Julia working directory,  \"somepath\" : Path as a    String e.g  \"/home/mpastell/weaveout\"  nbconvert cell timeout in seconds. Defaults to -1 (no timeout)   source  You might wan't to use the  convert_doc  method below instead and run the code in Jupyter.",
            "title": "Output to Jupyter notebooks"
        },
        {
            "location": "/notebooks/#converting-between-formats",
            "text": "You can convert between all supported input formats using the  convert_doc  function.  To convert from script to notebook:  convert_doc ( \"examples/FIR_design.jl\" ,   \"FIR_design.ipynb\" )   and from notebooks to markdown use:  convert_doc ( \"FIR_design.ipynb\" ,   \"FIR_design.jmd\" )   #  Weave.convert_doc  \u2014  Method .  convert_doc(infile::AbstractString, outfile::AbstractString; format = nothing)  Convert Weave documents between different formats   infile  = Name of the input document  outfile  = Name of the output document  format  = Output format (optional). Detected from outfile extension, but can be set to  \"script\" ,  \"markdown\" ,  \"notebook\"  or  \"noweb\" .   source",
            "title": "Converting between formats"
        },
        {
            "location": "/function_index/",
            "text": "Function index\n\n\n\n\nWeave.convert_doc\n\n\nWeave.get_chunk_defaults\n\n\nWeave.include_weave\n\n\nWeave.list_out_formats\n\n\nWeave.notebook\n\n\nWeave.restore_chunk_defaults\n\n\nWeave.tangle\n\n\nWeave.weave",
            "title": "Function index"
        },
        {
            "location": "/function_index/#function-index",
            "text": "Weave.convert_doc  Weave.get_chunk_defaults  Weave.include_weave  Weave.list_out_formats  Weave.notebook  Weave.restore_chunk_defaults  Weave.tangle  Weave.weave",
            "title": "Function index"
        }
    ]
}