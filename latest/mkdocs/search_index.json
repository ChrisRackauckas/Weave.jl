{
    "docs": [
        {
            "location": "/",
            "text": "Intro\n\n\nThis is the documentation of \nWeave.jl\n. Weave is a scientific report generator/literate programming tool for Julia. It resembles \nPweave\n and, Knitr and Sweave.\n\n\nCurrent features\n\n\n\n\nNoweb or markdown syntax for input documents.\n\n\nExecute code as terminal or \"script\" chunks.\n\n\nCapture Gadfly, PyPlot or Winston figures.\n\n\nSupports LaTex, Pandoc and Github markdown, AsciiDoc and reStructuredText output\n\n\n\n\n\n\n\n\nContents\n\n\n\n\nChunk options\n\n\nOptions for code\n\n\nOptions for figures\n\n\nSet default chunk options\n\n\n\n\n\n\nFunction index\n\n\nGetting started\n\n\nIntro\n\n\nContents\n\n\n\n\n\n\nPublishing scripts\n\n\nOther mark ups with scripts\n\n\n\n\n\n\nUsing Weave\n\n\nWeave\n\n\nWeave from shell\n\n\nTangle\n\n\nSupported formats\n\n\nDocument syntax\n\n\nNoweb\n\n\nMarkdown",
            "title": "Home"
        },
        {
            "location": "/#intro",
            "text": "This is the documentation of  Weave.jl . Weave is a scientific report generator/literate programming tool for Julia. It resembles  Pweave  and, Knitr and Sweave.  Current features   Noweb or markdown syntax for input documents.  Execute code as terminal or \"script\" chunks.  Capture Gadfly, PyPlot or Winston figures.  Supports LaTex, Pandoc and Github markdown, AsciiDoc and reStructuredText output",
            "title": "Intro"
        },
        {
            "location": "/#contents",
            "text": "Chunk options  Options for code  Options for figures  Set default chunk options    Function index  Getting started  Intro  Contents    Publishing scripts  Other mark ups with scripts    Using Weave  Weave  Weave from shell  Tangle  Supported formats  Document syntax  Noweb  Markdown",
            "title": "Contents"
        },
        {
            "location": "/getting_started/",
            "text": "Getting started\n\n\nThe best way to get started using Weave.jl is to look at the example input and output documents. Examples for different formats are included in the packages \nexamples\n directory.\n\n\nFirst have a look at source document using markdown code chunks and Gadfly for figures: \ngadfly_md_sample.jmd\n and then see the output in different formats:\n\n\n\n\nPandoc markdown: \ngadfly_md_sample.md\n\n\nHTML: \ngadfly_md_sample.html\n\n\npdf: \ngadfly_md_sample.pdf\n\n\n\n\nProducing HTML and pdf output requires that you have Pandoc and XeLatex (for pdf) installed.\n\n\nYou can Weave the files to your working directory using:\n\n\nusing Weave\n#Markdown\nweave(Pkg.dir(\"Weave\",\"examples\",\"gadfly_md_sample.jmd\"), out_path = :pwd,\n  doctype = \"pandoc\")\n#HTML\nweave(Pkg.dir(\"Weave\",\"examples\",\"gadfly_md_sample.jmd\"), out_path = :pwd,\n  doctype = \"md2html\")\n#pdf\nweave(Pkg.dir(\"Weave\",\"examples\",\"gadfly_md_sample.jmd\"), out_path = :pwd,\n  doctype = \"md2pdf\")",
            "title": "Getting started"
        },
        {
            "location": "/getting_started/#getting-started",
            "text": "The best way to get started using Weave.jl is to look at the example input and output documents. Examples for different formats are included in the packages  examples  directory.  First have a look at source document using markdown code chunks and Gadfly for figures:  gadfly_md_sample.jmd  and then see the output in different formats:   Pandoc markdown:  gadfly_md_sample.md  HTML:  gadfly_md_sample.html  pdf:  gadfly_md_sample.pdf   Producing HTML and pdf output requires that you have Pandoc and XeLatex (for pdf) installed.  You can Weave the files to your working directory using:  using Weave\n#Markdown\nweave(Pkg.dir(\"Weave\",\"examples\",\"gadfly_md_sample.jmd\"), out_path = :pwd,\n  doctype = \"pandoc\")\n#HTML\nweave(Pkg.dir(\"Weave\",\"examples\",\"gadfly_md_sample.jmd\"), out_path = :pwd,\n  doctype = \"md2html\")\n#pdf\nweave(Pkg.dir(\"Weave\",\"examples\",\"gadfly_md_sample.jmd\"), out_path = :pwd,\n  doctype = \"md2pdf\")",
            "title": "Getting started"
        },
        {
            "location": "/usage/",
            "text": "Using Weave\n\n\nYou can write your documentation and code in input document using Noweb or Markdown syntax and use \nweave\n function to execute to document to capture results and figures.\n\n\n\n\nWeave\n\n\nWeave document with markup and julia code using Gadfly for plots, \nout_path = :pwd\n makes the results appear in the current working directory.\n\n\nusing Weave\nweave(Pkg.dir(\"Weave\",\"examples\",\"gadfly_sample.mdw\"), out_path = :pwd)\n\n\n\n\nUsing PyPlot:\n\n\nweave(Pkg.dir(\"Weave\",\"examples\",\"julia_sample.mdw\"), plotlib=\"PyPlot\", out_path = :pwd)\n\n\n\n\n#\n\n\nWeave.weave\n \u2014 \nMethod\n.\n\n\n\n\nfunction weave(source ; doctype = :auto, plotlib=\"Gadfly\",         informat=:auto, out_path=:doc, fig_path = \"figures\", fig_ext = nothing,         cache_path = \"cache\", cache=:off)\n\n\nWeave an input document to output file.\n\n\n\n\ndoctype\n: :auto = set based on file extension or specify one of the supported formats.   See \nlist_out_formats()\n\n\nplotlib\n: \n\"PyPlot\"\n, \n\"Gadfly\"\n or \nnothing\n\n\ninformat\n: :auto = set based on file extension or set to  \n\"noweb\"\n, \n\"markdown\"\n or  \nscript\n\n\nout_path\n: Path where the output is generated. Can be: \n:doc\n: Path of the source document, \n:pwd\n: Julia working directory, \n\"somepath\"\n: output directory as a String e.g \n\"/home/mpastell/weaveout\"\n or filename as string e.g. ~/outpath/outfile.tex.\n\n\nfig_path\n: where figures will be generated, relative to out_path\n\n\nfig_ext\n: Extension for saved figures e.g. \n\".pdf\"\n, \n\".png\"\n. Default setting depends on \ndoctype\n.\n\n\ncache_path\n: where of cached output will be saved.\n\n\ncache\n: controls caching of code: \n:off\n = no caching, \n:all\n = cache everything,   \n:user\n = cache based on chunk options, \n:refresh\n, run all code chunks and save new cache.\n\n\n\n\nNote:\n Run Weave from terminal and not using IJulia, Juno or ESS, they tend to mess with capturing output.\n\n\n\n\nWeave from shell\n\n\nYou can also use the \nweave.jl\n script under bin directory to weave documents from the shell:\n\n\n$ ./weave.jl\nusage: weave.jl [--doctype DOCTYPE] [--plotlib PLOTLIB]\n                [--informat INFORMAT] [--out_path OUT_PATH]\n                [--fig_path FIG_PATH] [--fig_ext FIG_EXT] source...\n\n\n\n\n\n\nTangle\n\n\nTangling extracts the code from document:\n\n\n#\n\n\nWeave.tangle\n \u2014 \nMethod\n.\n\n\n\n\ntangle(source ; out_path=:doc, informat=\"noweb\")\n\n\nTangle source code from input document to .jl file.\n\n\n\n\ninformat\n: \n\"noweb\"\n of \n\"markdown\"\n\n\nout_path\n: Path where the output is generated. Can be: \n:doc\n: Path of the source document, \n:pwd\n: Julia working directory,  \n\"somepath\"\n, directory name as a string e.g \n\"/home/mpastell/weaveout\"\n or filename as string e.g. ~/outpath/outfile.jl.\n\n\n\n\n\n\nSupported formats\n\n\nWeave sets the output format based on the file extension, but you can also set it using \ndoctype\n option. The rules for detecting the format are:\n\n\next == \".jl\" && return \"md2html\"\ncontains(ext, \".md\") && return \"md2html\"\ncontains(ext, \".rst\") && return \"rst\"\ncontains(ext, \".tex\") && return \"texminted\"\ncontains(ext, \".txt\") && return \"asciidoc\"\nreturn \"pandoc\"\n\n\n\n\nYou can get a list of supported output formats:\n\n\njulia> list_out_formats()\npandoc: Pandoc markdown\nrst: reStructuredText and Sphinx\ntexminted: Latex using minted for highlighting\ngithub: Github markdown\nmd2html: Markdown to HTML (requires Pandoc)\nmd2pdf: Markdown to pdf (requires Pandoc and xelatex)\nasciidoc: AsciiDoc\ntex: Latex with custom code environments\n\n\n\n\n#\n\n\nWeave.list_out_formats\n \u2014 \nMethod\n.\n\n\n\n\nlist_out_formats()\n\n\nList supported output formats\n\n\n\n\nDocument syntax\n\n\nWeave uses noweb, markdown or script syntax for defining the code chunks and documentation chunks. The format is detected based on the file extension, but you can also set it manually using the \ninformat\n parameter.\n\n\nThe rules for autodetection are:\n\n\next == \".jl\" && return \"script\"\next == \".jmd\" && return \"markdown\"\nreturn \"noweb\"\n\n\n\n\n\n\nNoweb\n\n\n\n\nCode chunks\n\n\nstart with a line marked with \n<<>>=\n or \n<<options>>=\n and end with line marked with \n@\n. The code between the start and end markers is executed and the output is captured to the output document. See for options below.\n\n\n\n\nDocumentation chunks\n\n\nAre the rest of the document (between \n@\n and \n<<>>=\n lines and the first chunk be default) and can be written with several different markup languages.\n\n\nSample document\n\n\n\n\nMarkdown\n\n\nMarkdown code chunks are defined using fenced code blocks. \nSee sample document:",
            "title": "Using Weave"
        },
        {
            "location": "/usage/#using-weave",
            "text": "You can write your documentation and code in input document using Noweb or Markdown syntax and use  weave  function to execute to document to capture results and figures.",
            "title": "Using Weave"
        },
        {
            "location": "/usage/#weave",
            "text": "Weave document with markup and julia code using Gadfly for plots,  out_path = :pwd  makes the results appear in the current working directory.  using Weave\nweave(Pkg.dir(\"Weave\",\"examples\",\"gadfly_sample.mdw\"), out_path = :pwd)  Using PyPlot:  weave(Pkg.dir(\"Weave\",\"examples\",\"julia_sample.mdw\"), plotlib=\"PyPlot\", out_path = :pwd)  #  Weave.weave  \u2014  Method .   function weave(source ; doctype = :auto, plotlib=\"Gadfly\",         informat=:auto, out_path=:doc, fig_path = \"figures\", fig_ext = nothing,         cache_path = \"cache\", cache=:off)  Weave an input document to output file.   doctype : :auto = set based on file extension or specify one of the supported formats.   See  list_out_formats()  plotlib :  \"PyPlot\" ,  \"Gadfly\"  or  nothing  informat : :auto = set based on file extension or set to   \"noweb\" ,  \"markdown\"  or   script  out_path : Path where the output is generated. Can be:  :doc : Path of the source document,  :pwd : Julia working directory,  \"somepath\" : output directory as a String e.g  \"/home/mpastell/weaveout\"  or filename as string e.g. ~/outpath/outfile.tex.  fig_path : where figures will be generated, relative to out_path  fig_ext : Extension for saved figures e.g.  \".pdf\" ,  \".png\" . Default setting depends on  doctype .  cache_path : where of cached output will be saved.  cache : controls caching of code:  :off  = no caching,  :all  = cache everything,    :user  = cache based on chunk options,  :refresh , run all code chunks and save new cache.   Note:  Run Weave from terminal and not using IJulia, Juno or ESS, they tend to mess with capturing output.",
            "title": "Weave"
        },
        {
            "location": "/usage/#weave-from-shell",
            "text": "You can also use the  weave.jl  script under bin directory to weave documents from the shell:  $ ./weave.jl\nusage: weave.jl [--doctype DOCTYPE] [--plotlib PLOTLIB]\n                [--informat INFORMAT] [--out_path OUT_PATH]\n                [--fig_path FIG_PATH] [--fig_ext FIG_EXT] source...",
            "title": "Weave from shell"
        },
        {
            "location": "/usage/#tangle",
            "text": "Tangling extracts the code from document:  #  Weave.tangle  \u2014  Method .   tangle(source ; out_path=:doc, informat=\"noweb\")  Tangle source code from input document to .jl file.   informat :  \"noweb\"  of  \"markdown\"  out_path : Path where the output is generated. Can be:  :doc : Path of the source document,  :pwd : Julia working directory,   \"somepath\" , directory name as a string e.g  \"/home/mpastell/weaveout\"  or filename as string e.g. ~/outpath/outfile.jl.",
            "title": "Tangle"
        },
        {
            "location": "/usage/#supported-formats",
            "text": "Weave sets the output format based on the file extension, but you can also set it using  doctype  option. The rules for detecting the format are:  ext == \".jl\" && return \"md2html\"\ncontains(ext, \".md\") && return \"md2html\"\ncontains(ext, \".rst\") && return \"rst\"\ncontains(ext, \".tex\") && return \"texminted\"\ncontains(ext, \".txt\") && return \"asciidoc\"\nreturn \"pandoc\"  You can get a list of supported output formats:  julia> list_out_formats()\npandoc: Pandoc markdown\nrst: reStructuredText and Sphinx\ntexminted: Latex using minted for highlighting\ngithub: Github markdown\nmd2html: Markdown to HTML (requires Pandoc)\nmd2pdf: Markdown to pdf (requires Pandoc and xelatex)\nasciidoc: AsciiDoc\ntex: Latex with custom code environments  #  Weave.list_out_formats  \u2014  Method .   list_out_formats()  List supported output formats",
            "title": "Supported formats"
        },
        {
            "location": "/usage/#document-syntax",
            "text": "Weave uses noweb, markdown or script syntax for defining the code chunks and documentation chunks. The format is detected based on the file extension, but you can also set it manually using the  informat  parameter.  The rules for autodetection are:  ext == \".jl\" && return \"script\"\next == \".jmd\" && return \"markdown\"\nreturn \"noweb\"",
            "title": "Document syntax"
        },
        {
            "location": "/usage/#noweb",
            "text": "",
            "title": "Noweb"
        },
        {
            "location": "/usage/#code-chunks",
            "text": "start with a line marked with  <<>>=  or  <<options>>=  and end with line marked with  @ . The code between the start and end markers is executed and the output is captured to the output document. See for options below.",
            "title": "Code chunks"
        },
        {
            "location": "/usage/#documentation-chunks",
            "text": "Are the rest of the document (between  @  and  <<>>=  lines and the first chunk be default) and can be written with several different markup languages.  Sample document",
            "title": "Documentation chunks"
        },
        {
            "location": "/usage/#markdown",
            "text": "Markdown code chunks are defined using fenced code blocks.  See sample document:",
            "title": "Markdown"
        },
        {
            "location": "/publish/",
            "text": "Publishing scripts\n\n\nYou can also also publish html and pdf documents from Julia scripts with a specific format. Producing HTML and pdf output requires that you have Pandoc and XeLatex (for pdf) installed and in your path.\n\n\nThese scripts can be executed normally using Julia or published with Weave. Documentation is written in markdown in lines starting with \n#'\n, \n#%%\n or \n# %%\n , and code is executed and results are included in the published document.\n\n\nThe format is identical to \nPweave\n and the concept is similar to publishing documents with MATLAB or using Knitr's \nspin\n. Weave will remove the first empty space from each line of documentation.\n\n\nAll lines that are not documentation are treated as code. You can set chunk options using lines starting with \n#+\n, \n#%%\n or \n# %%\n just before code e.g. \n#+ term=True, caption='Fancy plots.'\n. See the example below for the markup.\n\n\nThe scripts can be published using the \npypublish\n scipts:\n\n\nFIR_design.jl\n, \nFIR_design.html\n , \nFIR_design.pdf\n.\n\n\nweave(\"FIR_design.jl\")\nweave(\"FIR_design.jl\", docformat = \"md2pdf\")\n\n\n\n\n\n\nOther mark ups with scripts\n\n\nYou can also use any Weave supported format in the comments and set the output format as you would for noweb and markdown inputs. e.g for LaTeX you can use:\n\n\nweave(\"latex_doc.jl\", docformat = \"texminted\")",
            "title": "Publishing scripts"
        },
        {
            "location": "/publish/#publishing-scripts",
            "text": "You can also also publish html and pdf documents from Julia scripts with a specific format. Producing HTML and pdf output requires that you have Pandoc and XeLatex (for pdf) installed and in your path.  These scripts can be executed normally using Julia or published with Weave. Documentation is written in markdown in lines starting with  #' ,  #%%  or  # %%  , and code is executed and results are included in the published document.  The format is identical to  Pweave  and the concept is similar to publishing documents with MATLAB or using Knitr's  spin . Weave will remove the first empty space from each line of documentation.  All lines that are not documentation are treated as code. You can set chunk options using lines starting with  #+ ,  #%%  or  # %%  just before code e.g.  #+ term=True, caption='Fancy plots.' . See the example below for the markup.  The scripts can be published using the  pypublish  scipts:  FIR_design.jl ,  FIR_design.html  ,  FIR_design.pdf .  weave(\"FIR_design.jl\")\nweave(\"FIR_design.jl\", docformat = \"md2pdf\")",
            "title": "Publishing scripts"
        },
        {
            "location": "/publish/#other-mark-ups-with-scripts",
            "text": "You can also use any Weave supported format in the comments and set the output format as you would for noweb and markdown inputs. e.g for LaTeX you can use:  weave(\"latex_doc.jl\", docformat = \"texminted\")",
            "title": "Other mark ups with scripts"
        },
        {
            "location": "/chunk_options/",
            "text": "Chunk options\n\n\nI've mostly followed \nKnitr\n's naming for chunk options, but not all options are implemented.\n\n\nOptions are separated using \";\" and need to be valid Julia expressions. Example: A code chunk that saves and displays a 12 cm wide image and hides the source code:\n\n\n<<fig_width=5; echo=false >>=\nusing Gadfly\nx = linspace(0, 2\u03c0, 200)\nplot(x=x, y = sin(x), Geom.line)\n@\n\n\n\n\nWeave currently supports the following chunk options with the following defaults:\n\n\n\n\nOptions for code\n\n\n\n\necho = true\n. Echo the code in the output document. If \nfalse\n the source code will be hidden.\n\n\nresults = \"markup\"\n. The output format of the printed results. \"markup\" for literal block, \"hidden\" for hidden results or anything else for raw output (I tend to use \u2018tex\u2019 for Latex and \u2018rst\u2019 for rest. Raw output is useful if you wan\u2019t to e.g. create tables from code chunks.\n\n\neval = true\n. Evaluate the code chunk. If false the chunk won\u2019t be executed.\n\n\nterm=false\n. If true the output emulates a REPL session. Otherwise only stdout and figures will be included in output.\n\n\nlabel\n. Chunk label, will be used for figure labels in Latex as fig:label\n\n\nwrap = true\n. Wrap long lines from output.\n\n\nline_width = 75\n. Line width for wrapped lines.\n\n\ncache = false\n. Cache results, depends on \ncache\n parameter on \nweave\n function.\n\n\nhold = false\n. Hold all results until the end of the chunk.\n\n\ntangle = true\n. Set tangle to false to exclude chunk from tangled code.\n\n\n\n\n\n\nOptions for figures\n\n\n\n\nfig_width\n. Figure width defined in markup, default depends on the output format.\n\n\nout_width\n. Width of saved figure.\n\n\nout_height\n. Height of saved figure.\n\n\ndpi\n=96. Resolution of saved figures.\n\n\nfig_cap\n. Figure caption.\n\n\nlabel\n. Chunk label, will be used for figure labels in Latex as fig:label\n\n\nfig_ext\n. File extension (format) of saved figures.\n\n\nfig_pos=\"htpb\"\n. Figure position in Latex.  \n\n\nfig_env=\"figure\"\n. Figure environment in Latex.\n\n\n\n\n\n\nSet default chunk options\n\n\nYou can set or alter the default chunk options for a document either before running weave or inside the weaved document. You can e.g. use a hidden chunk in the beginning of the source document to set the options:\n\n\n<<echo = false>>=\nimport Weave\nWeave.set_chunk_defaults(Dict{Symbol, Any}(\n      :out_width => \"\\\\0.5linewidth\",\n      :results => \"tex\"\n      ))\n@\n\n\n\n\n#\n\n\nWeave.set_chunk_defaults\n \u2014 \nMethod\n.\n\n\n\n\nset_chunk_defaults(opts::Dict{Symbol, Any})\n\n\nSet default options for code chunks, use get_chunk_defaults to see the current values.\n\n\ne.g. set default dpi to 200 and fig_width to 8\n\n\njulia> set_chunk_defaults(Dict{Symbol, Any}(:dpi => 200, fig_width => 8))\n\n\n\n\n#\n\n\nWeave.get_chunk_defaults\n \u2014 \nMethod\n.\n\n\n\n\nget_chunk_defaults()\n\n\nGet default options used for code chunks.\n\n\n#\n\n\nWeave.restore_chunk_defaults\n \u2014 \nMethod\n.\n\n\n\n\nrestore_chunk_defaults()\n\n\nRestore Weave.jl default chunk options",
            "title": "Chunk options"
        },
        {
            "location": "/chunk_options/#chunk-options",
            "text": "I've mostly followed  Knitr 's naming for chunk options, but not all options are implemented.  Options are separated using \";\" and need to be valid Julia expressions. Example: A code chunk that saves and displays a 12 cm wide image and hides the source code:  <<fig_width=5; echo=false >>=\nusing Gadfly\nx = linspace(0, 2\u03c0, 200)\nplot(x=x, y = sin(x), Geom.line)\n@  Weave currently supports the following chunk options with the following defaults:",
            "title": "Chunk options"
        },
        {
            "location": "/chunk_options/#options-for-code",
            "text": "echo = true . Echo the code in the output document. If  false  the source code will be hidden.  results = \"markup\" . The output format of the printed results. \"markup\" for literal block, \"hidden\" for hidden results or anything else for raw output (I tend to use \u2018tex\u2019 for Latex and \u2018rst\u2019 for rest. Raw output is useful if you wan\u2019t to e.g. create tables from code chunks.  eval = true . Evaluate the code chunk. If false the chunk won\u2019t be executed.  term=false . If true the output emulates a REPL session. Otherwise only stdout and figures will be included in output.  label . Chunk label, will be used for figure labels in Latex as fig:label  wrap = true . Wrap long lines from output.  line_width = 75 . Line width for wrapped lines.  cache = false . Cache results, depends on  cache  parameter on  weave  function.  hold = false . Hold all results until the end of the chunk.  tangle = true . Set tangle to false to exclude chunk from tangled code.",
            "title": "Options for code"
        },
        {
            "location": "/chunk_options/#options-for-figures",
            "text": "fig_width . Figure width defined in markup, default depends on the output format.  out_width . Width of saved figure.  out_height . Height of saved figure.  dpi =96. Resolution of saved figures.  fig_cap . Figure caption.  label . Chunk label, will be used for figure labels in Latex as fig:label  fig_ext . File extension (format) of saved figures.  fig_pos=\"htpb\" . Figure position in Latex.    fig_env=\"figure\" . Figure environment in Latex.",
            "title": "Options for figures"
        },
        {
            "location": "/chunk_options/#set-default-chunk-options",
            "text": "You can set or alter the default chunk options for a document either before running weave or inside the weaved document. You can e.g. use a hidden chunk in the beginning of the source document to set the options:  <<echo = false>>=\nimport Weave\nWeave.set_chunk_defaults(Dict{Symbol, Any}(\n      :out_width => \"\\\\0.5linewidth\",\n      :results => \"tex\"\n      ))\n@  #  Weave.set_chunk_defaults  \u2014  Method .   set_chunk_defaults(opts::Dict{Symbol, Any})  Set default options for code chunks, use get_chunk_defaults to see the current values.  e.g. set default dpi to 200 and fig_width to 8  julia> set_chunk_defaults(Dict{Symbol, Any}(:dpi => 200, fig_width => 8))  #  Weave.get_chunk_defaults  \u2014  Method .   get_chunk_defaults()  Get default options used for code chunks.  #  Weave.restore_chunk_defaults  \u2014  Method .   restore_chunk_defaults()  Restore Weave.jl default chunk options",
            "title": "Set default chunk options"
        },
        {
            "location": "/function_index/",
            "text": "Function index\n\n\n\n\nWeave.get_chunk_defaults\n\n\nWeave.restore_chunk_defaults\n\n\nWeave.set_chunk_defaults\n\n\nWeave.list_out_formats\n\n\nWeave.tangle\n\n\nWeave.weave",
            "title": "Function index"
        },
        {
            "location": "/function_index/#function-index",
            "text": "Weave.get_chunk_defaults  Weave.restore_chunk_defaults  Weave.set_chunk_defaults  Weave.list_out_formats  Weave.tangle  Weave.weave",
            "title": "Function index"
        }
    ]
}